{"categories":[],"posts":[{"content":" 相关项目 laravel-vue-iview 的 GitHub 地址 戳这里，此项目基本可用于实际开发工作。\n  Laravel 和 Vue 的项目搭建：基础篇  基础篇主要介绍的是 Vue 前端项目的搭建过程，本篇将会介绍前端的文件结构和 jwt 用户验证功能。\n考虑所有代码都写在这里，代码量太大的问题。建议下载 Github 的项目，这里只讲实现原理和思路。\n文件结构 前端的文件结构基本大同小异，以我项目为例：\n├── api // 接口 │ └── login.js ├── app.js ├── app.vue ├── bootstrap.js ├── components // 公共组件 │ └── ExampleComponent.vue ├── images // 图片资源 │ └── logo.jpg ├── lang // 多国语言 │ ├── en.js │ ├── index.js │ └── zh.js ├── libs // 代码库 │ └── util.js ├── router // 路由配置 │ ├── _import_development.js │ ├── _import_production.js │ ├── index.js │ └── router.js ├── store // vuex 配置 │ ├── getters.js │ ├── index.js │ └── modules ├── styles // 公共 css │ └── mixin.scss ├── utils // 公共函数库 │ ├── request.js │ └── storage.js └── views // 视图文件夹 ├── home ├── layout └── login 这里建议第一次学习时一次性创建好，在慢慢熟悉了这些结构之后，diy 自己的项目时就可以按需创建了。\nJWT 如果你没有听说过 jwt，建议你简单了解一下 什么是 JWT \u0026ndash; JSON WEB TOKEN。\nLaravel 安装 JWT 这里官方地址已经足够精炼，点击 官方文档 查看。\n当然，你也可以查看我之前写的一篇文章， Laravel5.5 安装 JWT。\n用户登录模块 让我们先思考一下登录需要完成哪些工作：\n输入用户信息 -\u0026gt; 发送请求到后端 -\u0026gt; 后端判断用户信息是否正确 -\u0026gt; 正确返回用户 token -\u0026gt; token 存储到 vuex 和 cookie 当中。\n","id":0,"section":"posts","summary":"相关项目 laravel-vue-iview 的 GitHub 地址 戳这里，此项目基本可用于实际开发工作。 Laravel 和 Vue 的项目搭建：基础篇 基础篇主要介绍的是 Vue 前端项目的搭建过程，本篇将会介绍前端的文","tags":["Laravel","Vue"],"title":"Laravel和Vue的项目搭建:进阶篇","uri":"https://donng.github.io/2020/04/laravel%E5%92%8Cvue%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6%E7%AF%87/","year":"2020"},{"content":" 本篇只是实现了 基础 的功能，对于实际的项目中的权限等还未涉及，这些会在后期逐步完善。\n  相关项目 laravel-vue-iview 的 GitHub 地址 戳这里，此项目基本可用于实际开发工作。\n Laravel 创建项目 # 使用 composer 命令创建 Laravel 项目 composer create-project --prefer-dist laravel/laravel blog 运行项目 执行 php artisan serve ,访问 127.0.0.1:8000 \nVue 扩展包 package.json 配置 初次接触 Vue 的同学，通常对于要安装什么扩展包感到迷茫。以下是 Laravel package.json 中默认的扩展包：\n\u0026quot;devDependencies\u0026quot;: { \u0026quot;axios\u0026quot;: \u0026quot;^0.18\u0026quot;, \u0026quot;bootstrap\u0026quot;: \u0026quot;^4.0.0\u0026quot;, \u0026quot;popper.js\u0026quot;: \u0026quot;^1.12\u0026quot;, \u0026quot;cross-env\u0026quot;: \u0026quot;^5.1\u0026quot;, \u0026quot;jquery\u0026quot;: \u0026quot;^3.2\u0026quot;, \u0026quot;laravel-mix\u0026quot;: \u0026quot;^2.0\u0026quot;, \u0026quot;lodash\u0026quot;: \u0026quot;^4.17.4\u0026quot;, \u0026quot;vue\u0026quot;: \u0026quot;^2.5.7\u0026quot; } 直接与 Vue 相关的有 vue 和 axios（网络请求工具，与 Ajax 功能类似），如果开发中、大型项目，vue-router（路由管理工具） 和 vuex（状态管理工具） 也必不可少。\n还有其他常用的扩展，例如支持 cookie 操作的 js-cookie，支持多国语言开发的 vue-i18n,支持 Sass 语法的 node-sass 等。\n此项目前端使用 iview 框架，加上这些常用扩展后的 package.json ：\n \u0026quot;devDependencies\u0026quot;: { \u0026quot;axios\u0026quot;: \u0026quot;^0.17\u0026quot;, \u0026quot;bootstrap\u0026quot;: \u0026quot;^4.0.0\u0026quot;, \u0026quot;bootstrap-sass\u0026quot;: \u0026quot;^3.3.7\u0026quot;, \u0026quot;cross-env\u0026quot;: \u0026quot;^5.1\u0026quot;, \u0026quot;jquery\u0026quot;: \u0026quot;^3.2\u0026quot;, \u0026quot;laravel-mix\u0026quot;: \u0026quot;^2.0\u0026quot;, \u0026quot;lodash\u0026quot;: \u0026quot;^4.17.4\u0026quot;, \u0026quot;node-sass\u0026quot;: \u0026quot;^4.7.2\u0026quot;, \u0026quot;vue\u0026quot;: \u0026quot;^2.5.7\u0026quot; }, \u0026quot;dependencies\u0026quot;: { \u0026quot;css-loader\u0026quot;: \u0026quot;^0.28.9\u0026quot;, \u0026quot;iview\u0026quot;: \u0026quot;^2.9.2\u0026quot;, \u0026quot;js-cookie\u0026quot;: \u0026quot;^2.2.0\u0026quot;, \u0026quot;less\u0026quot;: \u0026quot;^3.0.0\u0026quot;, \u0026quot;less-loader\u0026quot;: \u0026quot;^4.0.5\u0026quot;, \u0026quot;particles.js\u0026quot;: \u0026quot;^2.0.0\u0026quot;, \u0026quot;vue-i18n\u0026quot;: \u0026quot;^7.4.2\u0026quot;, \u0026quot;vue-router\u0026quot;: \u0026quot;^3.0.1\u0026quot;, \u0026quot;vuex\u0026quot;: \u0026quot;^3.0.1\u0026quot; } 其中还加入了 css加载器、less解析工具、particles 前端动画等，不需要的可以自行删除。\n安装扩展包 将以上配置直接粘贴到你的 package.json 文件中，执行 cnpm install 或者 yarn install。\n没有 cnpm 的，需要设置淘宝镜像，npm 下载的是国外的镜像，速度慢而且可能出现下载失败的问题。\n# 设置淘宝镜像命令 npm install -g cnpm --registry=https://registry.npm.taobao.org 如果想单个安装扩展，可以执行命令如下：\ncnpm install vue-router --save 前端结构搭建 vue前端的文件结构在 /recources/assets/js 目录，vue能够渲染主要是两个操作\n vue 挂载到页面的节点中 vue-router 处理路由，渲染对应的组件  1. 建立 html 文件 在 resource/views 新建 index.blade.php,代码如下\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html style=\u0026#34;height: 100%\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1,user-scalable=0\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;csrf-token\u0026#34; content=\u0026#34;{{ csrf_token() }}\u0026#34;\u0026gt; \u0026lt;title\u0026gt;laravel-vue-iview项目\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;height: 100%\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{ mix(\u0026#39;js/app.js\u0026#39;) }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2. 修改 /recources/assets/js.app.js require('./bootstrap'); // 导入扩展包 window.Vue = require('vue'); import App from './app.vue' import VueRouter from 'vue-router'; import iView from 'iview'; import 'iview/dist/styles/iview.css'; // 导入vue Vue.use(iView); Vue.use(VueRouter); // 路由配置 const RouterConfig = { routes: [ // ExampleComponent laravel默认的示例组件 { path: '/', component: require('./components/ExampleComponent.vue') }, ] }; const router = new VueRouter(RouterConfig); const app = new Vue({ el: '#app', router: router, render: h =\u0026gt; h(App) }); 3. 建立 Layout 在 /recources/assets/js 新建 app.vue, 将 iview 的 layout 代码搬过来：\n\u0026lt;style scoped\u0026gt; .layout-con{ height: 100%; width: 100%; } .menu-item span{ display: inline-block; overflow: hidden; width: 69px; text-overflow: ellipsis; white-space: nowrap; vertical-align: bottom; transition: width .2s ease .2s; } .menu-item i{ transform: translateX(0px); transition: font-size .2s ease, transform .2s ease; vertical-align: middle; font-size: 16px; } .collapsed-menu span{ width: 0px; transition: width .2s ease; } .collapsed-menu i{ transform: translateX(5px); transition: font-size .2s ease .2s, transform .2s ease .2s; vertical-align: middle; font-size: 22px; } \u0026lt;/style\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026quot;layout\u0026quot;\u0026gt; \u0026lt;Layout :style=\u0026quot;{minHeight: '100vh'}\u0026quot;\u0026gt; \u0026lt;Sider collapsible :collapsed-width=\u0026quot;78\u0026quot; v-model=\u0026quot;isCollapsed\u0026quot;\u0026gt; \u0026lt;Menu active-name=\u0026quot;1-2\u0026quot; theme=\u0026quot;dark\u0026quot; width=\u0026quot;auto\u0026quot; :class=\u0026quot;menuitemClasses\u0026quot;\u0026gt; \u0026lt;MenuItem name=\u0026quot;1-1\u0026quot;\u0026gt; \u0026lt;Icon type=\u0026quot;ios-navigate\u0026quot;\u0026gt;\u0026lt;/Icon\u0026gt; \u0026lt;span\u0026gt;Option 1\u0026lt;/span\u0026gt; \u0026lt;/MenuItem\u0026gt; \u0026lt;MenuItem name=\u0026quot;1-2\u0026quot;\u0026gt; \u0026lt;Icon type=\u0026quot;search\u0026quot;\u0026gt;\u0026lt;/Icon\u0026gt; \u0026lt;span\u0026gt;Option 2\u0026lt;/span\u0026gt; \u0026lt;/MenuItem\u0026gt; \u0026lt;MenuItem name=\u0026quot;1-3\u0026quot;\u0026gt; \u0026lt;Icon type=\u0026quot;settings\u0026quot;\u0026gt;\u0026lt;/Icon\u0026gt; \u0026lt;span\u0026gt;Option 3\u0026lt;/span\u0026gt; \u0026lt;/MenuItem\u0026gt; \u0026lt;/Menu\u0026gt; \u0026lt;/Sider\u0026gt; \u0026lt;Layout\u0026gt; \u0026lt;Header :style=\u0026quot;{background: '#fff', boxShadow: '0 2px 3px 2px rgba(0,0,0,.1)'}\u0026quot;\u0026gt;\u0026lt;/Header\u0026gt; \u0026lt;Content :style=\u0026quot;{padding: '0 16px 16px'}\u0026quot;\u0026gt; \u0026lt;Breadcrumb :style=\u0026quot;{margin: '16px 0'}\u0026quot;\u0026gt; \u0026lt;BreadcrumbItem\u0026gt;Home\u0026lt;/BreadcrumbItem\u0026gt; \u0026lt;BreadcrumbItem\u0026gt;Components\u0026lt;/BreadcrumbItem\u0026gt; \u0026lt;BreadcrumbItem\u0026gt;Layout\u0026lt;/BreadcrumbItem\u0026gt; \u0026lt;/Breadcrumb\u0026gt; \u0026lt;Card\u0026gt; \u0026lt;div style=\u0026quot;height: 600px\u0026quot;\u0026gt;Content\u0026lt;/div\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/Content\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data () { return { isCollapsed: false }; }, computed: { menuitemClasses: function () { return [ 'menu-item', this.isCollapsed ? 'collapsed-menu' : '' ] } } } \u0026lt;/script\u0026gt; 4. 添加组件 路由访问的组件会渲染到 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;, 所以我们修改上面的 app.vue，将 content 文字修改为 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;，上面的代码是已经修改过得。\n然后修改组件 /recources/assets/js/components/ExampleComponent.vue 的内容：\n\u0026lt;template\u0026gt; \u0026lt;Tabs\u0026gt; \u0026lt;TabPane label=\u0026quot;macOS\u0026quot; icon=\u0026quot;social-apple\u0026quot;\u0026gt;标签一的内容\u0026lt;/TabPane\u0026gt; \u0026lt;TabPane label=\u0026quot;Windows\u0026quot; icon=\u0026quot;social-windows\u0026quot;\u0026gt;标签二的内容\u0026lt;/TabPane\u0026gt; \u0026lt;TabPane label=\u0026quot;Linux\u0026quot; icon=\u0026quot;social-tux\u0026quot;\u0026gt;标签三的内容\u0026lt;/TabPane\u0026gt; \u0026lt;/Tabs\u0026gt; \u0026lt;/template\u0026gt; 5. 创建 web 路由 在 /routes/web.php 中新建一个访问我们挂载着vue页面的路由。\nRoute::get('/', function () { return view('index'); }); 6. 编译运行 常用的编译命令如下：\n# 本地环境编译 npm run dev # 本地环境编译 + 监控文件修改 npm run watch # 生产环境编译 npm run prod 这里我使用 npm run dev，编译成功后访问项目就可以看到我们创建的 vue 页面了。\n至此，只是完成了基础的搭建过程，一个完整的项目还需要合理的 项目结构 和 基础的权限管理 等，这些内容也会逐步在此项目中完善。最终的目的是为了开发新项目时，可以 拿来就用,而不是每次重新再配置一遍。\n","id":1,"section":"posts","summary":"本篇只是实现了 基础 的功能，对于实际的项目中的权限等还未涉及，这些会在后期逐步完善。 相关项目 laravel-vue-iview 的 GitHub 地址 戳这里，此项目基本可用于实际开发工作。 Laravel","tags":["Laravel","Vue"],"title":"Laravel和Vue的项目搭建:基础篇","uri":"https://donng.github.io/2020/04/laravel%E5%92%8Cvue%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87/","year":"2020"},{"content":"年底处理数据的时候，需要将其他部门 Excel 的数据转换为指定格式的文本格式。\n其中学到的两个操作，在这里记录一下：\n Excel 转换为文本文件 使用 PHP 脚本处理文本格式并输出  1. Excel 转换为文本文件 开发 Excel 另存为 txt 文本格式，如果文本中有中文，就会有编码问题，mac 下的文件导出为 UTF-16LE 的编码格式。\n2. 使用 PHP 脚本处理文本格式并输出 txt 的文本格式示例：\n1 3 2 4 1 3 2 4 期望得到的 txt 格式：\n1 2 3 4 5 1 2 3 4 5 需要处理每一行的数据，每一行数据用 PHP_EOL 分割，然后用空格（可能多个）分割每一行数据，再去处理和写入。\n$content = file_get_contents($filename); $content = file_get_contents($content, 'UTF-8', 'UTF-16LE') $rowArr = explode(PHP_EOL, $content); foreach ($rowArr as $row) { $arr = preg_split(\u0026quot;/\\s+/\u0026quot;, trim($row); // 处理对应格式，生成临时的数组 $tempArr = .... echo implode(' ', $tempArr) . \u0026quot;\\n\u0026quot;; } 通过 preg_split 使用正则匹配多个空格的情况，如果是固定的一个空格，explode 函数速度更快。\n最后执行脚本命令 php filename.php \u0026gt; des.txt\n","id":2,"section":"posts","summary":"年底处理数据的时候，需要将其他部门 Excel 的数据转换为指定格式的文本格式。 其中学到的两个操作，在这里记录一下： Excel 转换为文本文件 使用 PHP 脚本处理文本格","tags":["PHP"],"title":"使用PHP脚本做文本处理","uri":"https://donng.github.io/2020/01/%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC%E5%81%9A%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/","year":"2020"},{"content":"多态的定义：对于接口的多种不同实现方式。\n例如，程序中定义一个数据存储的 set() 接口，我们分别用 MySQL 和 Redis 实现了 set() 的不同内部逻辑，这两种实现方式就实现了 多态 的概念。\nPHP 和 Go 实现多态的方式不同，PHP 作为动态类型的语言实现起来更加“松散”，Go 作为静态类型的语言则更加严格，当然其中还有语言本身的特性。\nPHP 的实现 在我使用 PHP 的编程中，接口 interface 的使用频率屈指可数。原因是 PHP 作为动态类型的语言，本身就不需要声明变量类型，而这也是 PHP 能够快速开发 web 应用的核心之一。\n接下来我们用程序设计多态的实现，假定一个实现面积计算的接口\ninterface Area { public function get(); } 然后是两个实现：矩形和三角形\n// 矩形 class Rectangle implements Area { public function getArea($a, $b) { return $a * $b; } } // 三角形 class Triangle implements Area { public function getArea($a, $b) { return $a * $b / 2; } } 然后在使用时，就可以使用 interface 作为参数约束了\nfunction myArea(Area $area, $a, $b) { return $area-\u0026gt;getArea($a, $b); } 但是因为 PHP 是动态类型的语言，不需要对参数的类型约束，完全可以用以上方式写代码，然后 interface 的定义就略显累赘，当然在框架设计中还是可以看到 interface 的使用场景，interface 确实明确的定义了实现的行为。但是开发中我不太会用 interface， 就算需要时也是用继承来实现，在 PHP 中继承完美覆盖了 interface 的作用，既可以约束子类实现的相同行为，还可以定义默认行为和扩展。\nfunction myArea($area, $a, $b) { return $area-\u0026gt;getArea($a, $b); } Go 的实现 Go 作为静态类型的语言，需要强制对变量的类型声明，这里再用 Go 实现一次上述简单的功能，首先定义接口：\ntype area interface { Get(int, int) int } 然后定义矩形和三角形的实现：\n// 矩形 type Rectangle struct {} func (Rectangle) Get(a int, b int) int { return a * b } // 三角形 type Triangle struct {} func (Triangle) Get(a int, b int) int { return a * b / 2 } // 多态的调用 func myArea(ar area, a int, b int) int { return ar.Get(a, b) } 总结 Go 的 interface 在项目中随处可见，而 PHP 开发中很少见。以上程序还存在一个问题，变量 a，b 义在两个实现中含义是不同的，这时扩展梯形时两个变量就会出现问题，需要将 a, b 放到 struct 结构体中，而 PHP 则是放在构造函数中。\n","id":3,"section":"posts","summary":"多态的定义：对于接口的多种不同实现方式。 例如，程序中定义一个数据存储的 set() 接口，我们分别用 MySQL 和 Redis 实现了 set() 的不同内部逻辑，这两种实现方式就实现了","tags":["PHP","Go"],"title":"PHP和Go实现多态的对比","uri":"https://donng.github.io/2020/01/php%E5%92%8Cgo%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94/","year":"2020"},{"content":"查看 jwt 官方文档\n安装 // 安装jwt最新版本 composer require tymon/jwt-auth 1.0.0-rc.2 // 发布配置文件 php artisan vendor:publish --provider=\u0026quot;Tymon\\JWTAuth\\Providers\\LaravelServiceProvider\u0026quot; // 生成密钥 php artisan jwt:secret 配置Model和Controller 设置模型文件 User.php 的内容如下：\n\u0026lt;?php namespace App; use Tymon\\JWTAuth\\Contracts\\JWTSubject; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable implements JWTSubject { use Notifiable; // Rest omitted for brevity  /** * Get the identifier that will be stored in the subject claim of the JWT. * * @return mixed */ public function getJWTIdentifier() { return $this-\u0026gt;getKey(); } /** * Return a key value array, containing any custom claims to be added to the JWT. * * @return array */ public function getJWTCustomClaims() { return []; } } 创建权限控制器\nphp artisan make:controller AuthController 更新控制器内容：\n\u0026lt;?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\Auth; use App\\Http\\Controllers\\Controller; class AuthController extends Controller { /** * Create a new AuthController instance. * * @return void */ public function __construct() { $this-\u0026gt;middleware(\u0026#39;auth:api\u0026#39;, [\u0026#39;except\u0026#39; =\u0026gt; [\u0026#39;login\u0026#39;]]); } /** * Get a JWT via given credentials. * * @return \\Illuminate\\Http\\JsonResponse */ public function login() { $credentials = request([\u0026#39;email\u0026#39;, \u0026#39;password\u0026#39;]); if (! $token = auth()-\u0026gt;attempt($credentials)) { return response()-\u0026gt;json([\u0026#39;error\u0026#39; =\u0026gt; \u0026#39;Unauthorized\u0026#39;], 401); } return $this-\u0026gt;respondWithToken($token); } /** * Get the authenticated User. * * @return \\Illuminate\\Http\\JsonResponse */ public function me() { return response()-\u0026gt;json(auth()-\u0026gt;user()); } /** * Log the user out (Invalidate the token). * * @return \\Illuminate\\Http\\JsonResponse */ public function logout() { auth()-\u0026gt;logout(); return response()-\u0026gt;json([\u0026#39;message\u0026#39; =\u0026gt; \u0026#39;Successfully logged out\u0026#39;]); } /** * Refresh a token. * * @return \\Illuminate\\Http\\JsonResponse */ public function refresh() { return $this-\u0026gt;respondWithToken(auth()-\u0026gt;refresh()); } /** * Get the token array structure. * * @param string $token * * @return \\Illuminate\\Http\\JsonResponse */ protected function respondWithToken($token) { return response()-\u0026gt;json([ \u0026#39;access_token\u0026#39; =\u0026gt; $token, \u0026#39;token_type\u0026#39; =\u0026gt; \u0026#39;bearer\u0026#39;, \u0026#39;expires_in\u0026#39; =\u0026gt; auth()-\u0026gt;factory()-\u0026gt;getTTL() * 60 ]); } } 配置守卫和路由 配置config/auth.php,将默认的 guard 修改为 api,并将 guards 的 driver 修改为 jwt,配置之后就可以将 Laravel 提供的 auth（用户认证） 和 jwt 结合起来。\n'defaults' =\u0026gt; [ 'guard' =\u0026gt; 'api', 'passwords' =\u0026gt; 'users', ], ... 'guards' =\u0026gt; [ 'api' =\u0026gt; [ 'driver' =\u0026gt; 'jwt', 'provider' =\u0026gt; 'users', ], ], 配置routes/api.php\nRoute::group([ 'middleware' =\u0026gt; 'api', 'prefix' =\u0026gt; 'auth' ], function ($router) { Route::post('login', 'AuthController@login'); Route::post('logout', 'AuthController@logout'); Route::post('refresh', 'AuthController@refresh'); Route::post('me', 'AuthController@me'); }); 你现在应该可以通过post登录（例如：http://example.dev/auth/login）得到如下响应:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600 } 验证请求 一下有几种途径发送token\n Authorization 头信息  Authorization: Bearer eyJhbGciOiJIUzI1NiI...  url查询参数  http://example.dev/me?token=eyJhbGciOiJIUzI1NiI... ","id":4,"section":"posts","summary":"查看 jwt 官方文档 安装 // 安装jwt最新版本 composer require tymon/jwt-auth 1.0.0-rc.2 // 发布配置文件 php artisan vendor:publish --provider=\u0026quot;Tymon\\JWTAuth\\Providers\\LaravelServiceProvider\u0026quot; // 生成密钥 php artisan jwt:secret 配置Model和Controller 设置模型文件 User.php 的内容","tags":["Laravel","JWT","PHP"],"title":"Laravel5.5 安装 JWT","uri":"https://donng.github.io/2020/01/laravel5.5%E5%AE%89%E8%A3%85jwt/","year":"2020"},{"content":"Faker 是一个虚拟数据的生成器，可以用它填充数据库进行压力测试或者创建优雅的 XML 文档。\n安装 如果项目支持 composer ,使用以下命令安装。不支持请到 Faker 的 Github 仓库下载源码，放入项目的扩展包文件夹中。\ncomposer require fzaninotto/faker 为了演示功能，我使用以下命令创建了一个新项目：\n// 创建新项目文件夹 mkdir data-seeder cd data-seeder // 安装 faker 扩展 composer require fzaninotto/faker 基本使用方法 在根目录下创建测试文件 test.php，输入以下代码:\n\u0026lt;?php require_once __DIR__ . \u0026#39;/vendor/fzaninotto/faker/src/autoload.php\u0026#39;; $faker = Faker\\Factory::create(); echo $faker-\u0026gt;name, \u0026#34;\\n\u0026#34;; echo $faker-\u0026gt;address, \u0026#34;\\n\u0026#34;; echo $faker-\u0026gt;text; 在 CLI 模式下运行脚本， php test.php 查看输出结果。faker 的结果是随机生成的：\nProf. Kailyn Barton 9230 Herzog Groves Suite 005 Gusikowskihaven, CO 60533-4716 Nesciunt voluptas debitis iusto consectetur possimus mollitia in quam. Vel non rem temporibus illo numquam est. Sit fugit sed fugit id eligendi eaque sunt possimus. faker 的专有名词 faker 中定义了一些专有名词帮助我们理解它的设计思路，明白这些概念对理解他的源码非常有帮助。\n格式器（formatters） 除了以上三个属性，faker 还提供了大量可供选择的模拟数据。每个生成器属性（例如上面使用的 name，address 和 lorem）都被叫做 格式器（formatters）。\n提供器（providers） 我们需要填充的数据有很多种类，例如\n 基本的随机数据：整数、浮点数、字母 随机的人物信息：姓名、姓、名 等 随机的号码：手机号、电话号  Faker 将每种分类定义为 provider，查看 data-seeder/vendor/fzaninotto/faker/src/Faker/Provider 可以看到各种 provider 的类文件，以及分语言包的文件。\n源码解析 faker 扩展包体积虽小，五脏俱全，非常有学习价值。\nfaker 对象生成 查看 faker 生成器的工厂方法：\nconst DEFAULT_LOCALE = \u0026#39;en_US\u0026#39;; protected static $defaultProviders = array(\u0026#39;Address\u0026#39;, \u0026#39;Barcode\u0026#39;, \u0026#39;Biased\u0026#39;, \u0026#39;Color\u0026#39;, \u0026#39;Company\u0026#39;, \u0026#39;DateTime\u0026#39;, \u0026#39;File\u0026#39;, \u0026#39;HtmlLorem\u0026#39;, \u0026#39;Image\u0026#39;, \u0026#39;Internet\u0026#39;, \u0026#39;Lorem\u0026#39;, \u0026#39;Miscellaneous\u0026#39;, \u0026#39;Payment\u0026#39;, \u0026#39;Person\u0026#39;, \u0026#39;PhoneNumber\u0026#39;, \u0026#39;Text\u0026#39;, \u0026#39;UserAgent\u0026#39;, \u0026#39;Uuid\u0026#39;); public static function create($locale = self::DEFAULT_LOCALE) { $generator = new Generator(); foreach (static::$defaultProviders as $provider) { $providerClassName = self::getProviderClassname($provider, $locale); $generator-\u0026gt;addProvider(new $providerClassName($generator)); } return $generator; } 参数 locale 是语言包，默认为 en_US 美国英语。在 data-seeder/vendor/fzaninotto/faker/src/Faker/Provider 目录中可以查看所有支持的语言包。\n默认的 providers（provider 已经在上面提到过），在以上 Provider 目录中可以一一对应的找到。循环数组，将对应的 provider 添加到生成器 $generator。\ngetProviderClassname protected static function getProviderClassname($provider, $locale = \u0026#39;\u0026#39;) { if ($providerClass = self::findProviderClassname($provider, $locale)) { return $providerClass; } // fallback to default locale if ($providerClass = self::findProviderClassname($provider, static::DEFAULT_LOCALE)) { return $providerClass; } // fallback to no locale if ($providerClass = self::findProviderClassname($provider)) { return $providerClass; } throw new \\InvalidArgumentException(sprintf(\u0026#39;Unable to find provider \u0026#34;%s\u0026#34; with locale \u0026#34;%s\u0026#34;\u0026#39;, $provider, $locale)); } getProviderClassname 将按照以下逻辑寻找 provider 类，如果不存在于当前文件就到下一级文件查找，找不到就会跑出异常：\n用户传入的语言包文件夹 -\u0026gt; 默认的en_US语言包文件夹 -\u0026gt; Provider根目录 addProvider public function addProvider($provider) { array_unshift($this-\u0026gt;providers, $provider); } addProvider 就非常简单了，只是把找到的 provider 加入数组头部，数组存储在将要返回的 $generator 对象的属性中。\nfaker 对象调用 在使用 faker 返回的对象时，有两种方式：调用属性和调用方法。这些调用都会触发魔术方法：\npublic function format($formatter, $arguments = array()) { return call_user_func_array($this-\u0026gt;getFormatter($formatter), $arguments); } public function __get($attribute) { return $this-\u0026gt;format($attribute); } public function __call($method, $attributes) { return $this-\u0026gt;format($method, $attributes); } 两者逻辑类似，这里说明相对麻烦一点的 __call 魔术方法，魔术方法会将调用的方法名和参数传入 farmat 方法。\ngetFormatter public function getFormatter($formatter) { if (isset($this-\u0026gt;formatters[$formatter])) { return $this-\u0026gt;formatters[$formatter]; } foreach ($this-\u0026gt;providers as $provider) { if (method_exists($provider, $formatter)) { $this-\u0026gt;formatters[$formatter] = array($provider, $formatter); return $this-\u0026gt;formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf(\u0026#39;Unknown formatter \u0026#34;%s\u0026#34;\u0026#39;, $formatter)); } $this-\u0026gt;formatters 中存储的就是 faker 专有名词那里提到的 formatter（格式器）相关的信息。为了方便理解，这里以获得数组中一个随机元素为例，说明这些抽象的概念。\n$faker-\u0026gt;randomElement(['a', 'b', 'c']); 当调用此方法时，触发魔术方法，然后遍历每一个 provider 类，查找是否存在此方法。直到在 Base.php 中发现存在此方法，此时要使用的提供器 provider 为 Base.php，格式器 formatter 就是 randomElement() 方法。\n然后就需要将 Base 中存在 randomeElement() 的对应关系存储起来，避免下次重新遍历所有 provider，这就是 $this-\u0026gt;formatters 实现的原因。\n此方法返回对应的 provider 和 formatters 后，通过 call_user_func_array 调用并返回结果。\n至此，一个完整的 faker 对象生成和调用的过程就结束了。\n","id":5,"section":"posts","summary":"Faker 是一个虚拟数据的生成器，可以用它填充数据库进行压力测试或者创建优雅的 XML 文档。 安装 如果项目支持 composer ,使用以下命令安装。不支持请到 Faker 的 Github 仓库下载","tags":["PHP"],"title":"Faker虚拟数据填充和源码解","uri":"https://donng.github.io/2019/12/faker%E8%99%9A%E6%8B%9F%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","year":"2019"},{"content":"Github Actions 阅读阮一峰的入门教程： http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\nactions 英文介绍：https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#name\n官方的 actions 特性介绍：https://github.com/features/actions\n优秀 actions 的仓库：https://github.com/sdras/awesome-actions\nActions Badge Badge 中设置教程：https://lpd-ios.github.io/2017/05/03/GitHub-Badge-Introduction/\nBadge 英文网站：https://shields.io/\nBadge 英文文档：https://help.github.com/en/actions/automating-your-workflow-with-github-actions/configuring-a-workflow#example-using-a-workflow-file-path\n","id":6,"section":"posts","summary":"Github Actions 阅读阮一峰的入门教程： http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html actions 英文介绍：https://help.github.com/en/actions/automating-your","tags":["Github"],"title":"Github Actions 和 Badge 设置的资源","uri":"https://donng.github.io/2019/12/github-actions-%E5%92%8C-badge-%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%B5%84%E6%BA%90/","year":"2019"},{"content":"本文以当前最新版本 PHP 7.3.1 演示整个源码安装的流程。\n下载 PHP 源码包 访问 PHP 官网的源码包下载地址 http://php.net/downloads.php。\n如图所示，PHP 源码提供了三种压缩格式，通常压缩后的文件越小，意味着解压缩需要的时间和 CPU 消耗就会更多，这里要根据安装 PHP 的服务器硬件情况和带宽选择合适的压缩格式，我选择下载 php-7.3.1.tar.gz。\n下载源码有两种方式：\n 服务器端使用 wget 命令直接下载 。 首先下载到本地，然后通过 FTP 传到服务器。  以第一种方法为例，在服务器端执行：\nwget -c http://cn2.php.net/distributions/php-7.3.1.tar.gz 点开其中一个压缩包，右击 China 的 cn2.php.net 复制链接地址，可以获得另一个下载地址，获取方式如下图所示：\nhttp://cn2.php.net/get/php-7.3.1.tar.gz/from/this/mirror # 此地址的下载命令，使用 -O 重命名源码包，否则下载后的文件名会是 mirror wget -O php-7.3.1.tar.gz http://cn2.php.net/get/php-7.3.1.tar.gz/from/this/mirror 如果需要下载其他版本，只需要修改下载地址中的版本号，例如 php-7.2.14.tar.gz。\n安装 PHP 使用 tar 命令解压 tar.gz 压缩包：\ntar -xzvf php-7.3.1.tar.gz 安装 PHP 需要的扩展库\nyum install -y libxml2 *openssl* libcurl* libjpeg* libpng* freetype* libzip* libmcrypt* 进入解压后的 php-7.2.4 文件夹，运行 configure 可执行文件：\n./configure --prefix=/mnt/php7 --with-mysqli --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir --enable-simplexml --enable-xml --disable-rpath --enable-bcmath --enable-soap --enable-zip --with-curl --enable-fpm --with-fpm-user=www --with-fpm-group=www --enable-mbstring --enable-sockets --with-gd --with-openssl --with-mhash --enable-opcache --disable-fileinfo 如果最后显示以上界面，说明已经成功安装。\n 由于我测试的是一个新的服务器，所以依次遇到了以下错误，没有出现问题可以跳过这部分：\n错误1：\nconfigure: error: in `/root/php-7.3.1': configure: error: no acceptable C compiler found in $PATH # 缺少 c 编译器，安装 GCC yum install gcc 错误2：\nchecking for libzip... configure: error: system libzip must be upgraded to version \u0026gt;= 0.11 # 查看 yum 安装的 libzip 版本 yum list installed | grep libzip # 发现 yum 安装的 libzip 版本过低，卸载低版本 yum remove libzip* 源码安装 libzip\n# 源码编译安装 libzip 最新版 # libzip 官网地址：https://libzip.org wget https://nih.at/libzip/libzip-1.5.1.tar.gz tar -zxvf libzip-1.5.1.tar.gz cd libzip-1.5.1 ## 查看 INSTALL.md 其中有安装提示 mkdir build cd build cmake .. make make test make install 上述命令在执行 cmake .. 时报错，使用 yum 安装了 gcc-c++\nyum -y install gcc-c++ 又重新源码编译安装了了 Cmake，参考这篇文章 。\n错误3：\nerror: off_t undefined; check your library configuration # 添加搜索路径到配置文件 echo '/usr/local/lib64 /usr/local/lib /usr/lib /usr/lib64'\u0026gt;\u0026gt;/etc/ld.so.conf # 更新配置 ldconfig -v 此错误详细解释参考 https://segmentfault.com/q/1010000007346459 中 @代码狗 的回答。\n 编译和安装\nmake \u0026amp;\u0026amp; make install 配置 进入 /mnt/php7/sbin，启动 php-fpm\n[root@localhost sbin]# ./php-fpm [15-Jan-2019 03:32:21] ERROR: failed to open configuration file '/mnt/php7/etc/php-fpm.conf': No such file or directory (2) [15-Jan-2019 03:32:21] ERROR: failed to load configuration file '/mnt/php7/etc/php-fpm.conf' [15-Jan-2019 03:32:21] ERROR: FPM initialization failed 解决办法：\n# 进入 /mnt/php7/etc，复制 php-fpm 的配置文件 [root@localhost etc]# cp php-fpm.conf.default php-fpm.conf # 进入 /mnt/php7/etc/php-fpm.d，复制 php-fpm 的子配置文件： [root@localhost php-fpm.d]# cp www.conf.default www.conf 在运行 php-fpm 前，还需要修改其子配置文件中的用户和用户组，以 nginx 为例，编辑 /mnt/php7/etc/php-fpm.d 文件：\nuser = nginx group = nginx 至此就可以启动 php-fpm 了。\n在命令行下运行 php，需要将可执行文件复制到环境变量下：\ncp /mnt/php7/bin/php /usr/local/bin/php # 命令行下查看 php 版本 php -v ","id":7,"section":"posts","summary":"本文以当前最新版本 PHP 7.3.1 演示整个源码安装的流程。 下载 PHP 源码包 访问 PHP 官网的源码包下载地址 http://php.net/downloads.php","tags":["PHP"],"title":"源码安装 PHP 7.3","uri":"https://donng.github.io/2019/12/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85-php-7.3/","year":"2019"},{"content":"变量指向一个内存地址，其中存储了某种类型的值。在静态语言中，此内存存储的变量类型不可变。\n Go 中的变量如何声明？ Go 变量声明可以指定哪些类型？ Go 中如何实现类型的转换和断言？  1. Go 中的变量如何声明 使用 var 关键词声明变量，有以下几种可变形式：\n 简单的类型声明：var a int 声明并赋初值：var a int = 1 或 var a = 1 同时声明多个变量： var a, b = 1, 2  当声明初始值时，可以不用指定类型，Go 会根据赋值判断并自动定义变量的类型。\n以下为变量声明的示例：\npackage main import \u0026quot;fmt\u0026quot; func main() { var a int var b int = 2 var c = 3 var d, e = 4, 5 fmt.Printf(\u0026quot;a: %d, b: %d, c: %d, d: %d, e: %d\u0026quot;, a, b, c, d, e) } Go 还提供了省略 var 关键词的声明方式，需要注意的是，已经声明的变量不能再次使用 :=，除非左边有新的变量：\npackage main import \u0026quot;fmt\u0026quot; func main() { a := 1 fmt.Println(a) a, b := 2, 3 fmt.Printf(\u0026quot;a: %d, b: %d\u0026quot;, a, b) } 2. Go 变量声明可以指定哪些类型  数字类型 字符串类型 布尔类型   数字类型： int和uint的大小与运行环境的位数相关，int8是8bit，取值范围为-128到127\nint,int8,int16,int32,int64 uint,uint8,uint16,uint32,uint64 complex 是复数类型\nfloat32,float64,complex64,complex128 字符串类型 字符串底层是作为一个字节序列存储的\n布尔类型就是我们常用的 true 和 false\n3. Go 中如何实现类型的转换  int -\u0026gt; int64 string -\u0026gt; int int -\u0026gt; string  更多转换查看 strconv包。\n注意：int 转换为 int64 在32位机器上存在精度问题。\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strconv\u0026quot; ) func main() { // int 到 int64 a := 1 b := int64(a) fmt.Printf(\u0026quot;a: %d, b: %d\u0026quot;, a, b) // string 到 int c := \u0026quot;123\u0026quot; d, _ := strconv.Atoi(c) fmt.Printf(\u0026quot;c: %s, d %d\u0026quot;, c, d) // int 到 string e := 234 f := strconv.Itoa(e) fmt.Printf(\u0026quot;e: %d, f %s\u0026quot;, e, f) // float32 到 string g := 3.14 h := strconv.FormatFloat(g, 'E', -1, 32) fmt.Printf(\u0026quot;g: %f, h: %s\u0026quot;, g, h) } Reference  Strings in Go strconv  ","id":8,"section":"posts","summary":"变量指向一个内存地址，其中存储了某种类型的值。在静态语言中，此内存存储的变量类型不可变。 Go 中的变量如何声明？ Go 变量声明可以指定哪些类型？ Go 中","tags":["Go"],"title":"Go语言笔记：变量","uri":"https://donng.github.io/2019/12/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%8F%98%E9%87%8F/","year":"2019"},{"content":" 数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性：\n 请求空间以后大小固定，不能再改变（数据溢出问题）； 在内存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间； 在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。   以上引用自维基百科。\n传统数组的局限性导致了动态数组的诞生。然而动态数组也不是使用动态的内存，依旧是一块连续的内存。那它是如何实现数组大小不固定的呢？原因是当超过数组容量时，程序将自动执行扩容操作：\n 重新开辟一块大小为当前数组容量两倍的内存 把原数组的数据拷贝到此内存空间 释放原数组的内存  本文将从概念上实现动态数组的扩容和缩容特性，并实现数组增删查改操作的方法。\n查看 Github 代码\n数组结构 我们自定义的数组结构 Array 基于 Go 的 slice 实现，维护 size 字段可以让我们方便的获取数组元素的个数，当我们需要获取元素总数时，就不需要循环 data 去计算。\ntype Array struct { data []interface{} // 泛型数组  size int // 元素数量 } 数组接口 使用接口声明我们需要实现的方法，Go 语言没有继承的关键字，实现接口定义的所有方法就会自动继承该接口。\ntype ArrayInterface interface { // 添加  Add(int, interface{}) // 插入元素  AddLast(interface{}) AddFirst(interface{}) // 删除  Remove(int) interface{} RemoveFirst() interface{} RemoveLast() interface{} // 查找  Find(interface{}) int // 查找元素返回第一个索引  FindAll(interface{}) []int // 查找元素返回所有索引  Contains(interface{}) bool // 查找是否存在元素  Get(int) interface{} // 修改  Set(int, interface{}) // 基本方法  GetCapacity() int // 获得数组容量  GetSize() int // 获得元素个数  IsEmpty() bool // 查看数组是否为空 } 数组实现 扩/缩容规则 数组 resize 指当数组元素超过数组容量，或者元素小于数组容量时，需要完成的扩容和缩容规则：\n 超过数组容量，按照当前容量的 2 倍扩容。 数组元素个数为当前容量 1/4 时，缩容为当前容量的一半。  为什么缩容不是 1/2？\n如果在 1/2 时缩容，会导致在扩容的临界点添加、删除一个元素都是 O(n) 复杂度的情况（临界点添加一个元素，导致扩容为 2 倍，此时删除刚添加的元素，又会缩容为 1/2）。\n数组的方法实现 构造函数 Go 没有提供构造函数，我们可以声明一个公共的函数代替\n// 获得自定义数组，参数为数组的初始长度 func GetArray(capacity int) *Array { arr := \u0026amp;Array{} arr.data = make([]interface{}, capacity) arr.size = 0 return arr } 基本方法 // 获得数组容量 func (a *Array) GetCapacity() int { return len(a.data) } // 获得数组元素个数 func (a *Array) GetSize() int { return a.size } // 判断数组是否为空 func (a *Array) IsEmpty() bool { return a.size == 0 } 数组容量调整 容量调整的逻辑为，声明一个新的数组，将原数组的元素赋值给新数组。\n// newCapacity 新数组容量 // 逻辑：声明新的数组，将原数组的值 copy 到新数组中 func (a *Array) resize(newCapacity int) { newArr := make([]interface{}, newCapacity) for i := 0; i \u0026lt; a.size; i++ { newArr[i] = a.data[i] } a.data = newArr } 查找元素 查找元素指输入元素返回元素的索引\n// 获得元素的首个索引，不存在则返回 -1 func (a *Array) Find(element interface{}) int { for i:= 0; i \u0026lt; a.size; i++ { if element == a.data[i] { return i } } return -1 } // 获得元素的所有索引，返回索引组成的切片 func (a *Array) FindAll(element interface{}) (indexes []int) { for i := 0; i \u0026lt; a.size; i++ { if element == a.data[i] { indexes = append(indexes, i) } } return } // 查看数组是否存在元素，返回 bool func (a *Array) Contains(element interface{}) bool { if a.Find(element) == -1 { return false } return true } // 获得索引对应元素，需要判断索引有效范围 func (a *Array) Get(index int) interface{} { if index \u0026lt; 0 || index \u0026gt; a.size - 1 { panic(\u0026#34;Get failed, index is illegal.\u0026#34;) } return a.data[index] } 修改元素 修改索引对应元素值 func (a *Array) Set(index int, element interface{}) { if index \u0026lt; 0 || index \u0026gt; a.size - 1 { panic(\u0026#34;Set failed, index is illegal.\u0026#34;) } a.data[index] = element } 添加元素 添加元素需要考虑扩容问题，同时 AddLast 和 AddFirst 都是基于 Add 实现的，这非常的方便。\nfunc (a *Array) Add(index int, element interface{}) { if index \u0026lt; 0 || index \u0026gt; a.GetCapacity() { panic(\u0026#34;Add failed, require index \u0026gt;= 0 and index \u0026lt;= capacity\u0026#34;) } // 数组已满则扩容 \tif a.size == len(a.data) { a.resize(2 * a.size) } // 将插入的索引位置之后的元素后移，腾出插入位置 \tfor i := a.size - 1; i \u0026gt;= index; i-- { a.data[i + 1] = a.data[i] } a.data[index] = element // 维护数组元素的数量 \ta.size++ } func (a *Array) AddLast(element interface{}) { a.Add(a.size, element) } func (a *Array) AddFirst(element interface{}) { a.Add(0, element) } 删除元素 删除元素需要考虑缩容问题\nfunc (a *Array) Remove(index int) interface{} { if index \u0026lt; 0 || index \u0026gt;= a.size { panic(\u0026#34;Remove failed, index is illegal.\u0026#34;) } removeEle := a.data[index] // 从 index 之后的元素，都向前移动一个位置 \tfor i := index + 1; i \u0026lt; a.size; i++ { a.data[i-1] = a.data[i] } a.size-- // 清理最后一个元素 \ta.data[a.size] = nil // 考虑边界情况，不能 resize 为0 \tif a.size == len(a.data)/4 \u0026amp;\u0026amp; len(a.data)/2 != 0 { a.resize(len(a.data) / 2) } return removeEle } func (a *Array) RemoveFirst() interface{} { return a.Remove(0) } func (a *Array) RemoveLast() interface{} { return a.Remove(a.size - 1) } 重写 String 方法 重写数组打印时的展示形式，只需要重写 String 方法\nfunc (a *Array) String() string { var buffer bytes.Buffer buffer.WriteString(fmt.Sprintf(\u0026#34;Array: size = %d, capacity = %d\\n\u0026#34;, a.size, a.GetCapacity())) buffer.WriteString(\u0026#34;[\u0026#34;) for i := 0; i \u0026lt; a.size; i++ { buffer.WriteString(fmt.Sprint(a.data[i])) if i != a.size - 1 { buffer.WriteString(\u0026#34;,\u0026#34;) } } buffer.WriteString(\u0026#34;]\u0026#34;) return buffer.String() } 最终测试 func main() { arr := GetArray(10) for i := 0; i \u0026lt; 10; i++ { arr.AddLast(i) } fmt.Println(arr) arr.Add(1, 100) fmt.Println(arr) arr.AddFirst(-1) fmt.Println(arr) } 输出结果：\nArray: size = 10, capacity = 10 [0,1,2,3,4,5,6,7,8,9] Array: size = 11, capacity = 20 [0,100,2,2,3,4,5,6,7,8,9] Array: size = 12, capacity = 20 [-1,100,100,2,2,3,4,5,6,7,8,9] 时间复杂度分析 添加操作  Add(int, interface{}) O(n) AddLast(interface{}) O(1) AddFirst(interface{}) O(n)  AddLast 涉及到扩容的操作，容量为 n 的数组添加 n + 1 个元素，会操作 2n + 1 次，因为第 n + 1 次操作导致扩容，原数组需要copy n 次，其平均操作次数为 2 次，所以均摊复杂度是O(1)。\n删除操作  Remove(int) interface{} O(n) RemoveFirst() interface{} O(n) RemoveLast() interface{} O(1)  RemoveFirst 会将第一个元素之后的所有元素前移一个位置，Remove 也可能是移除第一个元素，它们都是 n 的复杂度，而 RemoveLast 只需要移除最后一个元素。\n查找操作  Find(interface{}) int O(n) FindAll(interface{}) []int O(n) Contains(interface{}) bool O(n) Get(int) interface{} O(1)  Find 类的操作都需要遍历数组，为 n 的复杂度。Get 可以直接通过键获得值，这也是数组的优势所在。\n修改操作  Set(int, interface{}) O(1)  总结 可以发现，数组对已知索引和数组尾部的操作都是 O(1) 的复杂度，我们可以将这些理解为数组的优势，当我们用数组实现一些功能就可以充分利用这些优势。\n例如，我们用数组模拟一个栈的操作，如果用数组尾部模拟栈顶，入栈、出栈都是都是 O(1) 时间复杂度，这是非常高效的。但是将出入栈放到数组头部，时间复杂度就变成 O(n) 了，差距是显而易见。\n","id":9,"section":"posts","summary":"数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性： 请求空间以后大小固定，不能再改变（数据溢出问题","tags":["Go"],"title":"Go语言实现动态数组","uri":"https://donng.github.io/2019/10/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/","year":"2019"},{"content":"PHP 大文件上传占用大量资源，因此需要对上传的大小进行限制，以下为相关的三个参数：\n nginx 的 client_max_body_size php.ini 的 upload_max_filesize php.ini 的 post_max_size  与以上相对应的三个报错信息：\n 状态码 413 Request Entiry Too Large. Warning: POST Content-Length of 9663102 bytes exceeds the limit of 8388608 bytes in Unknown on line 0 $_FILES['file']['error']==1  nginx错误：413 Request Entiry Too Large client_max_body_size 用于设置客户端 Request body（请求体）的大小上限，要上传的文件就在 body 体 中，所以此参数可以间接的看做是对文件上传大小的限制。\nnginx 服务器通过请求头的 Content-Length 确定 body 体的大小。超过设置的上限会返回错误码 413 Request Entity Too Large，将此参数设置为 0 可以取消对长度的限制。\nSyntax:\tclient_max_body_size size; Default:\tclient_max_body_size 1m; Context:\thttp, server, location client_max_body_size 可以设置在 http、server、location 块中，所以我们可以对域名甚至一个请求地址来提高上传包的大小值。\nphp错误： Warning: POST Content-Length of 9663102 bytes exceeds the limit of 8388608 bytes in Unknown on line 0 此时为上传文件大小大于 post_max_size。\nphp 无警告但是获取不到上传的文件 此时 $_FILES['file']['error']==1，错误原因是上传文件的大小小于 post_max_size 但是大于 upload_max_filesize。\n","id":10,"section":"posts","summary":"PHP 大文件上传占用大量资源，因此需要对上传的大小进行限制，以下为相关的三个参数： nginx 的 client_max_body_size php.ini 的 upload_max_filesize php.ini 的 post_max_size 与以上相对应的三个报错信息： 状态码 413 Request Entiry Too Large.","tags":["PHP"],"title":"PHP 文件上传限制","uri":"https://donng.github.io/2019/09/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%99%90%E5%88%B6/","year":"2019"},{"content":"micro new myservice panic: qtls.ClientSessionState not compatible with tls.ClientSessionState goroutine 1 [running]: github.com/lucas-clemente/quic-go/internal/handshake.init.0() /go/src/github.com/lucas-clemente/quic-go/internal/handshake/unsafe.go:20 +0x113 解决方法： 安装 go1.12 版本。\n","id":11,"section":"posts","summary":"micro new myservice panic: qtls.ClientSessionState not compatible with tls.ClientSessionState goroutine 1 [running]: github.com/lucas-clemente/quic-go/internal/handshake.init.0() /go/src/github.com/lucas-clemente/quic-go/internal/handshake/unsafe.go:20 +0x113 解决方法： 安装 go1.12 版本。","tags":["go"],"title":"go-micro 启动报错","uri":"https://donng.github.io/2019/08/go-micro%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/","year":"2019"},{"content":" 热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。\n 首先在本地模拟一个线上需要升级 Nginx 的环境，假设旧版本为 nginx-1.0.15，需要升级到 nginx-1.16.0。\n配置旧版本 # 下载 nginx-1.0.15 wget http://nginx.org/download/nginx-1.0.15.tar.gz # 解压压缩包 tar -zxf nginx-1.0.15.tar.gz # 进入解压后的目录 cd nginx-1.0.15 # 配置 nginx ./configure --prefix=/home/nginx # 编译安装 make \u0026amp;\u0026amp; make install # 运行 nginx sudo /home/nginx/sbin/nginx 此时访问服务器地址应该可以看到 nginx 的欢迎页面了。\n获得新版本二进制 # 下载 nginx-1.16.0 wget http://nginx.org/download/nginx-1.16.0.tar.gz # 解压压缩包 tar -zxf nginx-1.16.0 # 进入解压后的目录 cd nginx-1.16.0/ # 配置 nginx ./configure --prefix=/home/nginx # 只编译不需要安装 make 在编译后的 objs 目录中，可以看到二进制文件 nginx。\n热部署 经过以上步骤，我们实现了一个正在运行的旧版本 nginx 和编译完成的新版本 nginx 二进制执行文件。\n热部署的流程是：\n 备份旧的 nginx 可执行文件 新的 nginx 可执行文件直接替换旧的（此时旧的 nginx 进程还在运行） 向 nginx master 进程发送热部署信号，新的 nginx 进程启动，旧的 worker 不再就收请求。 关闭旧的 worker 进程，完成热部署。  # 备份 cp /home/nginx/sbin/nginx /home/nginx/sbin/nginx.old # 替换 cp -f objs/nginx /home/nginx/sbin/nginx # 查看 master pid ps -ef | grep nginx root 23712 1 0 21:21 ? 00:00:00 nginx: master process /home/nginx/sbin/nginx nobody 23715 23712 0 21:21 ? 00:00:00 nginx: worker process # 发送热部署信号，这里 master pid 替换为自己查询到的 kill -USR2 23712 # 查看当前 nginx 进程情况，27522 就是新的 master 进程 ps -ef | grep nginx root 23712 1 0 21:21 ? 00:00:00 nginx: master process /home/nginx/sbin/nginx nobody 23715 23712 0 21:21 ? 00:00:00 nginx: worker process root 27522 23712 0 21:41 ? 00:00:00 nginx: master process /home/nginx/sbin/nginx nobody 27524 27522 0 21:41 ? 00:00:00 nginx: worker process # 关闭旧的 worker kill -WINCH 23712 # 再次查看进程，可以发现旧的worker进程关闭了 ps -ef | grep nginx root 23712 1 0 21:21 ? 00:00:00 nginx: master process /home/nginx/sbin/nginx root 27522 23712 0 21:41 ? 00:00:00 nginx: master process /home/nginx/sbin/nginx nobody 27524 27522 0 21:41 ? 00:00:00 nginx: worker process 保留旧的 master 进程是为了在新的版本存在问题时，可以快速回退到原版本。如果发现问题要紧急回滚呢？\ncp -f nginx.old nginx # 拉起旧版本的worker进程（-HUP 相当于 -s reload） kill -HUP old_master_pid # 让新版本的 worker 不再接受请求 kill -USR2 new_master_pid # 关闭新版本的 woker 进程 kill -WINCH new_master_pid 如果确认无误要退出老版本的 nginx，可以执行命令：\nkill -QUIT old_master_pid ","id":12,"section":"posts","summary":"热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。 首先在本地模拟一个线上需要升级 Nginx 的环境，假设旧版本为 nginx-1.0.15","tags":["Nginx"],"title":"模拟 Nginx 热部署","uri":"https://donng.github.io/2019/05/%E6%A8%A1%E6%8B%9F-nginx-%E7%83%AD%E9%83%A8%E7%BD%B2/","year":"2019"},{"content":"文章在 Golang 中文网的地址 点击这里，英语原文地址 点击这里。\n这是「Go 是一门设计糟糕的编程语言」系列追加的一篇文章。Go 确实有一些不错的特性，因此这篇文章也展示了它的优点。但是总的来说，当超过 API 或者网络服务器（这也是它的设计所在）的范畴，用 Go 处理商业领域的逻辑时，我感觉它用起来既麻烦又痛苦。就算在网络编程方面，Go 的设计和实现也存在诸多问题，这使它看上去简单实际则暗藏危险。\n写这篇文章的动机是因为我最近重新开始用 Go 写一个业余项目。在以前的工作中我广泛的使用了 Go 为 SaaS 服务编写网络代理（包括 http 和原始的 tcp）。Go 在网络编程方面体验很不错（我也正在探索这门语言），但随之而来的会计和账单部分则苦不堪言。因为我的业余项目只是一个简单的 API，我认为 Go 非常适合快速的完成这个任务。但是我们都知道，很多项目的需求增长会超过了预期，所以我不得不写一些数据处理程序来计算统计数据，Go 的痛苦之处也随着而来。下面就是我对 Go 的困扰。\n一些背景情况：我喜欢静态类型的语言。我第一个标志性的项目是用 Pascal 写的。当 90 年代初我开始工作之后，开始使用 Ada 和 C/C++。后来我转移到 Java 阵地，最后是 Scala（中间夹杂着 Go），最近开始学习 Rust。我也写了大量的 JavaScript，因为直到现在它依旧是浏览器端唯一可用的语言。我感觉动态类型的语言并不安全，并尽力将它们的使用限制在脚本级别。我习惯了命令式，函数式和面向对象的方法。\n这是一篇很长的文章，所以我整理了菜单来引起你的兴趣：\n 优点  Go 很容易学习 基于 goroutines 和 channels 的简单并发编程 丰富的标准库 Go 性能优越 语言层面定义源代码的格式化 标准化的测试框架 Go 程序方便操作 Defer 声明，避免忘记清理 新类型   缺点  Go 忽略了现代语言设计的进步 接口是结构类型 没有枚举 := 和 var 两难选择 零值会导致 panic Go 没有异常，等等\u0026hellip; 它是有的！   丑陋设计  依赖管理的噩梦 易变性被语言硬编码 切片（slice）陷阱 易变性和 channels：竞争条件更容易发生 杂乱的错误管理 Nil 接口值 Struct 字段标记：DSL 在字符串中的运行时间 没有泛型\u0026hellip;至少没给你 Go 在 slice 和 map 之外几乎没有别的数据结构 go generate，还说得过去，但是\u0026hellip;   结论 几天后：Hacker News 第三名!  优点 Go 很容易学习 这是事实：如果你了解任何一种编程语言，那么通过在 Go 语言之旅 学习几个小时就能够掌握 Go 的大部分语法，并在几天后写出你的第一个真正的程序。阅读并理解 实效 Go 编程，浏览一下 包文档，玩一玩 Gorilla 或者 Go Kit 这样的网络工具包，然后你就会成为一个相当不错的 Go 开发者。\n这是因为 Go 的首要目标是简单。当我开始学习 Go，它让我想起我第一次 发现 Java 的感觉：一个简单的语言和一个丰富但不臃肿的标准库。对比当前 Java 沉重的环境，学习 Go 是一个耳目一新的体验。因为 Go 的简易性，Go 程序可读性非常高，虽然错误处理增加了一些麻烦（更多的内容在下面）。\nGo 语言的简单性可能是错误的。引用 Rob Pike 的话，简单既是复杂，我们会看到简单背后有很多的陷阱等着我们去踩，极简主义会让我们违背 DRY(Don't Repeat Yourself) 原则。\n基于 goroutines 和 channels 的简单并发编程 Goroutines 可能是 Go 的最佳特性了。它们是轻量级的计算线程，与操作系统线程截然不同。\n当 Go 程序执行看似阻塞 I/O 的操作时，实际上 Go 运行时挂起了 goroutine ，当一个事件指示某个结果可用时恢复它。与此同时，其他 goroutines 已被安排执行。因此在同步编程模型下，我们具有了异步编程的可伸缩性优势。\nGoroutines 也是轻量级的：它们的堆栈 随需求增长和收缩，这意味着有 100 个甚至 1000 个 goroutines 都不是问题。\n我以前的应用程序中有一个 goroutine 漏洞：这些 goroutines 结束之前正在等待一个 channel 关闭，而这个 channel 永远不会关闭（一个常见的死锁问题）。这个进程毫无任何理由吃掉了 90 % 的 CPU ，而检查 expvars 显示有 600 k 空闲的 goroutines！我猜测 goroutine 调度程序占用了 CPU。\n当然，像 Akka 这样的 Actor 系统可以轻松 处理数百万的 Actors，部分原因是 actors 没有堆栈，但是他们远没有像 goroutines 那样简单地编写大量并发的请求/响应应用程序（即 http APIs）。\nchannel 是 goroutines 的通信方式：它们提供了一个便利的编程模型，可以在 goroutines 之间发送和接收数据，而不必依赖脆弱的低级别同步基本体。channels 有它们自己的一套 用法 和 模式。\n但是，使用 channels 必须仔细考虑，因为错误大小的 channels （默认情况下没有缓冲） 会导致死锁。下面我们还将看到，使用通道并不能阻止竞争情况，因为它缺乏不可变性。\n丰富的标准库 Go 的 标准库 非常丰富，特别是对于所有与网络协议或 API 开发相关的： http 客户端和服务器，加密，档案格式，压缩，发送电子邮件等等。甚至还有一个 html 解析器和相当强大的模板引擎去生成 text \u0026amp; html，它会自动过滤 XSS 攻击（例如在 Hugo 中的使用）。\n各种 APIs 一般都简单易懂。它们有时看起来过于简单：这个某种程度上是因为 goroutine 编程模型意味着我们只需要关心「看似同步」的操作。这也是因为一些通用的函数也可以替换许多专门的函数，就像 我最近发现的关于时间计算的问题。\nGo 性能优越 Go 编译为本地可执行文件。许多 Go 的用户来自 Python、Ruby 或 Node.js。对他们来说，这是一种令人兴奋的体验，因为他们看到服务器可以处理的并发请求数量大幅增加。当您使用非并发（Node.js）或全局解释器锁定的解释型语言时，这实际上是相当正常的。结合语言的简易性，这解释了 Go 令人兴奋的原因。\n然而与 Java 相比，在 原始性能基准测试 中，情况并不是那么清晰。Go 打败 Java 地方是内存使用和垃圾回收。\nGo 的垃圾回收器的设计目的是 优先考虑延迟，并避免停机，这在服务器中尤其重要。这可能会带来更高的 CPU 成本，但是在水平可伸缩的体系结构中，这很容易通过添加更多的机器来解决。请记住，Go 是由谷歌设计的，他们从不会在资源上面短缺。\n与 Java 相比，Go 的垃圾回收器（GC）需要做的更少，切片是一个连续的数组结构，而不是像 Java 那样的指针数组。类似地，Go maps 也使用 小数组作为 buckets，以实现相同的目的。这意味着垃圾回收器的工作量减少，并且 CPU 缓存本地化也更好。\nGo 同样在命令行实用程序中优于 Java，作为本地可执行文件，Go 程序没有启动消耗，反之 Java 首先需要加载和编译的字节码。\n语言层面定义源代码的格式化 我职业生涯中一些最激烈的辩论发生在团队代码格式的定义上。 Go 通过为代码定义规范格式来解决这个问题。 gofmt 工具会重新格式化您的代码，并且没有选项。\n不管你喜欢与否，gofmt 定义了如何对代码进行格式化，一次性解决了这个问题。\n标准化的测试框架 Go 在其标准库中提供了一个很好的 测试框架。它支持并行测试、基准测试，并包含许多实用程序，可以轻松测试网络客户端和服务器。\nGo 程序方便操作 与 Python，Ruby 或 Node.js 相比，必须安装单个可执行文件对于运维工程师来说是一个梦想。 随着越来越多的 Docker 的使用，这个问题越来越少，但独立的可执行文件也意味着小型的 Docker 镜像。\nGo 还具有一些内置的观察性功能，可以使用 expvar 包发布内部状态和指标，并易于添加新内容。但要小心，因为它们在默认的 http 请求处理程序中 自动公开，不受保护。Java 有类似的 JMX ，但它要复杂得多。\nDefer 声明，防止忘记清理 defer 语句的目的类似于 Java 的 finally：在当前函数的末尾执行一些清理代码，而不管此函数如何退出。defer 的有趣之处在于它跟代码块没有联系，可以随时出现。这使得清理代码尽可能接近需要清理的代码：\nfile, err := os.Open(fileName) if err != nil { return } defer file.Close() // 用文件资源的时候，我们再也不需要考虑何时关闭它 当然，Java的 试用资源 没那么冗长，而且 Rust 在其所有者被删除时会 自动声明资源，但是由于 Go 要求您清楚地了解资源清理情况，因此让它接近资源分配很不错。\n新类型 我喜欢类型，因为有些事情让我感到恼火和害怕，举个例子，我们到处把持久对象标识符当做 string 或 long 类型传递使用。 我们通常会在参数名称中对 id 的类型进行编码，但是当函数具有多个标识符作为参数并且某些调用不匹配参数顺序时，会造成细微的错误。\nGo 对新类型有一等支持，即类型为现有类型并赋予其独立身份，与原有类型不同。与包装相反，新类型没有运行时间开销。这允许编译器捕捉这种错误：\ntype UserId string // \u0026lt;-- new type type ProductId string func AddProduct(userId UserId, productId ProductId) {} func main() { userId := UserId(\u0026#34;some-user-id\u0026#34;) productId := ProductId(\u0026#34;some-product-id\u0026#34;) // 正确的顺序： 没有问题  AddProduct(userId, productId) // 错误的顺序：将会编译错误  AddProduct(productId, userId) // 编译错误：  // AddProduct 不能用 productId(type ProductId) 作为 type UserId的参数  // Addproduct 不能用 userId(type UserId) 作为type ProfuctId 的参数 } 不幸的是，缺乏泛型使得使用新类型变得麻烦，因为为它们编写可重用代码需要从原始类型转换值。\n缺点 Go 忽略了现代语言设计的进步 在少既是多中，Rob Pike 解释说 Go 是为了在谷歌取代 C 和 C++，它的前身是 Newsqueak ，这是他在80年代写的一种语言。Go 也有很多关于 Plan9 的参考，Plan9 是一个分布式操作系统，在贝尔实验室的80年代开发的。\n甚至有一个直接从 Plan9 获得灵感的 Go 汇编。为什么不使用 LLVM 来提供目标范围广泛且开箱即用的体系结构？我此处可能也遗漏了某些东西，但是为什么需要汇编？如果你需要编写汇编以充分利用 CPU ，那么不应该直接使用目标 CPU 汇编语言吗？\nGo 的创造者应该得到尊重，但是看起来 Go 的设计发生在平行宇宙（或者他们的 Plan9 lab？）中发生的，这些编译器和编程语言的设计在 90 年代和 2000 年中从未发生过。也可能 Go 是由一个会写编译器的系统程序员设计的。\n函数式编程吗？不要提它。泛型？你不需要，看看他们用 C++ 编写的烂摊子！尽管 slice、map 和 channel 都是泛型类型，我们将在下面看到。\nGo 的目标是替换 C 和 C++，很明显它的创建者也没有关注其他地方。但他们没有达到目标，因为在谷歌的 C 和 C++ 开发人员没有采用它。我的猜测是主要原因是垃圾回收器。低级别 C 开发人员强烈拒绝托管内存，因为他们无法控制什么时间发生什么情况。他们喜欢这种控制，即使它带来了额外的复杂性，并且打开了内存泄漏和缓冲溢出的大门。有趣的是，Rust 在没有 GC 的情况下采用了完全不同的自动内存管理方法。\nGo 反而在操作工具的领域吸引了 Python 和 Ruby 等脚本语言的用户。他们在 Go 中找到了一种方法，可以提高性能，减少 内存/cpu/磁盘 占用。还有更多的静态类型，这对他们来说是全新的。Go 的杀手级应用是 Docker ，它在 devops 世界中引起了广泛的应用。Kubernetes 的崛起加强了这一趋势。\n接口是结构类型 Go 接口就像 Java 接口或 Scala 和 Rust 特性（traits），它们定义了后来由类型实现的行为（我不称之为“类”）。\n与 Java 接口和 Scala 和 Rust 特性不同，类型不需要显式地指定接口实现：它只需要实现接口中定义的所有函数。所以 Go 的接口实际上是结构化的。\n我们可能认为，这是为了允许其他包中的接口实现，而不是它们适用的类型，比如 Scala 或 Kotlin 中的类扩展，或 Rust 特性，但事实并非如此：所有与类型相关的方法都必须在类型的包中定义。\nGo 并不是唯一使用结构化类型的语言，但我发现它有几个缺点：\n 找到实现给定接口的类型很难，因为它依赖于函数定义匹配。我通过搜索实现接口的类，经常发现 Java 或 Scala 中有趣的实现。 当向接口添加方法时，只有当它们用作此接口类型的值时，才会发现哪些类型需要更新。 相当一段时间这可能被忽视。 Go 建议使用非常少的方法构建小型的接口，这是防止这种情况的一种方式。 类型可能在不知不觉中实现了一个接口，因为它作为相应的方法。但是偶然的，实现的语义可能与接口契约所期望的不同。  更新：对于接口的一些丑陋问题，请参阅下面的 无接口值（nil interface values）。\n没有枚举 Go 没有枚举，在我看来，这是一个错失的机会。\niota 可以快速生成自动递增的值，但它看起来更像一个技巧而不是一个特性。实际上，由于在一系列的 iota 生成的常量中插入一行会改变下列值的值，这是很危险的。由于生成的值是在整个代码中使用的值，因此这会导致有趣的（而不是！）意外。\n这也意味着没有办法让编译器彻底检查 switch 语句，也无法描述类型中允许的值。\n:= 和 var 的两难选择 Go 提供两种方法来声明一个变量，并为其赋值： var x = \u0026quot;foo\u0026quot; 和 x:= \u0026quot;foo\u0026quot;。这是为什么呢？\n主要的区别是 var 允许未初始化的声明（然后您必须声明类型），比如在 var x string 中，而 := 需要赋值，并且允许混合使用现有变量和新变量。我的猜测是 := 被发明来使错误处理减少一点麻烦：\n使用 var\nvar x, err1 = SomeFunction() if (err1 != nil) { return nil } var y, err2 = SomeOtherFunction() if (err2 != nil) { return nil } 使用 :=:\nx, err := SomeFunction() if (err != nil) { return nil } y, err := SomeOtherFunction() if (err != nil) { return nil } := 的语法也很容易意外的影响一个变量。我已经不止一次吃这个亏了，因为 := （声明和赋值）太接近了 = （赋值），如下图所示：\nfoo := \u0026#34;bar\u0026#34; if someCondition { foo := \u0026#34;baz\u0026#34; doSomething(foo) } // foo == \u0026#34;bar\u0026#34; 即使 \u0026#34;someCondition\u0026#34; 为真 零值 panic Go 没有构造函数。正因为如此，它坚持认为「零值」应该是易于使用的。这是一个有趣的方法，但在我看来，它所带来的简化主要是针对语言实现者的。\n在实践中，许多类型在没有正确初始化的情况下不能做有用的事情。让我们看一下 io.File 对象，从 实效 Go 编程 取出的一个例子：\ntype File struct { *file // os specific } func (f *File) Name() string { return f.name } func (f *File) Read(b []byte) (n int, err error) { if err := f.checkValid(\u0026#34;read\u0026#34;); err != nil { return 0, err } n, e := f.read(b) return n, f.wrapErr(\u0026#34;read\u0026#34;, e) } func (f *File) checkValid(op string) error { if f == nil { return ErrInvalid } return nil } 我们能发现什么？\n 在一个零值 File 调动 Name() 将会导致 panic ，因为它的 file 字段是 nil Read 函数和 几乎所有其他 File 方法，首先检查文件是否被初始化。  因此，零值 File 不仅无用，还会导致 panics。你必须使用一个构造函数，比如 Open 或 Create。检查正确的初始化是每个函数调用中需要花费的开销。\n在标准库中有无数这样的类型，有些甚至不尝试用它们的零值来做一些有用的事情。在零值 html.Template 上调用任何方法都会导致 panic。\n还有一个很严重的问题：map 的零值:你可以查询它，但是在它里面存储东西会导致 panic：\nvar m1 = map[string]string{} // 空值 map var m0 map[string]string // 零值 map (nil)  println(len(m1)) // 输出 \u0026#39;0\u0026#39; println(len(m0)) // 输出 \u0026#39;0\u0026#39; println(m1[\u0026#34;foo\u0026#34;]) // 输出 \u0026#39;\u0026#39; println(m0[\u0026#34;foo\u0026#34;]) // 输出 \u0026#39;\u0026#39; m1[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34; // 没问题 m0[\u0026#34;foo\u0026#34;] = \u0026#34;bar\u0026#34; // panics! 这需要在结构具有 map 字段时小心，因为在添加条目之前必须对其进行初始化。\n因此，作为一个开发人员，您必须经常检查您想要使用的结构是否需要调用构造函数，或者零值是否可用。这是语言简化对编程带来的沉重负担。\nGo 没有异常。哦，等一下……它有! 这篇博客文章「为什么 Go 获得异常的方式是对的」详细解释了为什么异常是糟糕的，为什么Go方法要求返回 错误 是更好的。我可以同意这一点，确实在使用异步编程或像 Java 流这样的函数风格时，异常是很难处理的（前者可以放到一边，由于 goroutines 的原因它在 Go 中是没有必要的，而后者几乎是不可能）。这篇博文提到 panic 「总是对你的程序抛出致命错误，游戏结束」，这很不错。\n现在，「Defer, panic and recover」在它之前，解释了如何从 panic 中恢复（通过实际捕获它们），并说「在真实的 panic 和 recover 的例子中，从 Go 标准库中看到 json 包」。\n事实上，json 解码器有一个 共同的错误处理函数 去 panics，panic 在顶层 unmarshal函数中恢复（recover），检查panic类型 并返回一个错误如果它是一个“本地 panic ”或其它错误再次触发的 panic（ 失去最初的 panic 的追溯）。\n对于任何 Java 开发人员来说，这明显看上去是一个try / catch (DecodingException ex)。所以 Go 确实有异常处理，它在内部使用了却告诉你不要用。\n有趣的事实：几个星期前，一个非谷歌的人修复了 json 解码器，以使用常规的错误冒泡处理。\n令人厌恶的点 依赖管理噩梦 首先引用一个在谷歌著名的 Go 语言使用者 Jaana Dogan (aka JBD) 的话，最近在推特上发泄她的不满:\n 如果依赖管理再过一年还没有解决，我将会考虑退出 Go 并且永远不会回来。 依赖性管理问题经常颠覆我从语言中获得的所有乐趣。\n— JBD (@rakyll) March 21, 2018\n 简单点说，Go 中没有依赖管理。当前所有的解决方案都只是一些技巧和变通方法。\n这要追溯到它的起源 \u0026ndash; 谷歌，以使用了一个 巨大的单片存储库 管理所有源代码而闻名。不需要模块的版本控制，也不需要第三方模块的仓库，你可以从当前分支构建任何项目。不幸的是，这在开放的互联网上是行不通。\n在 Go 中添加依赖意味着将依赖的源代码仓库克隆到你的 GOPATH 下。版本是什么？克隆当前的主分支就行了，管它写的是什么。但是如果不同的项目需要不同的版本依赖呢？他们做不到。因为「版本」的概念根本不存在。\n另外，您自己的项目必须在 GOPATH 下，否则编译器无法找到它。想让你的项目在单独的目录里清晰地组织起来？那你必须配置每一个项目的 GOPATH ，或者使用符号链接。\n社区已经开发了 大量的工具 解决此问题。包管理工具引入了 vendoring 和锁文件来保存您克隆的任何仓库的Git sha1，以提供可复现的构建。\n最后，在Go 1.6中，vendor 目录得到了官方支持。但它是关于你克隆的 vendoring，仍然不是正确的版本管理。没有对从传递依赖中导入发生冲突的解决方案，这通常是通过 语义化版本 来解决的。\n不过，情况正在好转：dep，官方的依赖管理工具 最近被引入以支持文件控制（vendoring）。它支持版本（git tags），并有一个遵循语义版本控制约定的版本解决程序。它还不稳定，但方向是正确的。然而，它仍然需要你的项目存放在 GOPATH 里。\n但是 dep 可能不会像 vgo长久，vgo 是谷歌发起的，想要从语言本身带来版本控制，并且最近已经引起了一些波动。\n所以 Go 的依赖管理是噩梦。设置起来很痛苦，当你在开发的时候你不会考虑到它，直到你添加一个新的导入（import）或者只是简单地想拉取你团队成员的一个分支到你的 GOPATH 里的时候，程序崩溃了\u0026hellip;\n现在让我们再次回到代码的问题上。\n易变性是用语言硬编码的。 在 Go 中没有定义不可变结构的方法: struct 字段是可变的，const 关键字不适用于它们。Go 通过简单的赋值就可以轻松地复制整个struct，因此，我们可能认为，通过值传递参数来保证不变性，只需要复制的代价。\n然而，不出所料的，它不复制指针引用的值。而且由于内置的集合（map、slice 和 array）是引用和可变的，复制包含其中任意一项的 struct 只是复制了指向底层内层的指针。\n下面的例子说明了这个问题：\ntype S struct { A string B []string } func main() { x := S{\u0026#34;x-A\u0026#34;, []string{\u0026#34;x-B\u0026#34;}} y := x // 复制 struct  y.A = \u0026#34;y-A\u0026#34; y.B[0] = \u0026#34;y-B\u0026#34; fmt.Println(x, y) // 输出 \u0026#34;{x-A [y-B]} {y-A [y-B]}\u0026#34; -- x 被修改! } 所以你必须非常小心，如果你通过值传递参数，不要认定它就是不变的。\n有一些 深度复制库 试图使用(慢)反射来解决这个问题，但是它们有不足之处，因为私有字段不能通过反射访问。因此，为了避免竞争条件而进行防御性复制将会很困难，需要大量的重复代码。Go甚至没有一个可以标准化这个的克隆接口。\n切片（slice）陷阱 切片带来了很多问题。正如「Go slice: usage and internals」中所解释的那样，考虑到性能原因，再次切片一个切片不会复制底层的数组。这是一个值得赞赏的目标，但也意味着切片的子切片只是遵循原始切片变化的视图。因此，如果您想要将它与初始的切片分开请不要忘记 copy()。\n对于 append 函数，忘记 copy() 会变得更加危险：如果它没有足够的容量来保存新值，底层数组将会重新分配内存和大小。这意味着 append 的结果能不能指向原始数组取决于它的初始容量。这会导致难以发现的不确定 bugs。\n在下面的代码中，我们看到为子切片追加值的影响取决于原始切片的容量：\nfunc doStuff(value []string) { fmt.Printf(\u0026#34;value=%v\\n\u0026#34;, value) value2 := value[:] value2 = append(value2, \u0026#34;b\u0026#34;) fmt.Printf(\u0026#34;value=%v, value2=%v\\n\u0026#34;, value, value2) value2[0] = \u0026#34;z\u0026#34; fmt.Printf(\u0026#34;value=%v, value2=%v\\n\u0026#34;, value, value2) } func main() { slice1 := []string{\u0026#34;a\u0026#34;} // 长度 1, 容量 1  doStuff(slice1) // Output:  // value=[a] -- ok  // value=[a], value2=[a b] -- ok: value 未改变, value2 被更新  // value=[a], value2=[z b] -- ok: value 未改变, value2 被更新  slice10 := make([]string, 1, 10) // 长度 1, 容量 10  slice10[0] = \u0026#34;a\u0026#34; doStuff(slice10) // Output:  // value=[a] -- ok  // value=[a], value2=[a b] -- ok: value 未改变, value2 被更新  // value=[z], value2=[z b] -- WTF！？ value 改变了？？？ } 易变性和 channels: 竞争条件更容易发生。 Go 并发性是 通过 channels 建立在CSP 上的，它使用 channel 使得协调 goroutines 比在共享数据上同步更简单和安全。老话说的是「不要通过共享内存来通信;而应该通过通信来共享内存」。这是一厢情愿的想法，在实践中是不能安全实现的。\n正如我们在上面看到的那样，Go 没办法获得不可变的数据结构。这意味着一旦我们在 channel 上发送一个指针，游戏就结束了：我们在并发进程之间共享了可变的数据。当然，一个 channel 的结构是赋值 channel 传送的值(而不是指针)，但是正如我们在上面看到的，这些没有深度复制引用，包括 slices 和 maps 本质上都是可变的。与接口类型的 struct 字段相同：它们是指针，接口定义的任何可变方法都是对竞争条件的开放。\n因此，尽管 channels 表面上使并发编程变得容易，但它们并不能阻止共享数据上的竞争条件。而 slices 和 maps 本身的可变性使这种情况更有可能发生。\n谈到竞争条件时，Go 包含一个 竞争条件检测模式，该模式检测代码以找到不同步的共享访问。它只能在事件发生的时候检测到竞争问题，所以大多数情况下是在集成或负载测试期间，希望这些能够运行比赛条件。由于它的高运行时成本(除了临时的调试会话)，它不能实际应用于生产环境。\n嘈杂的错误管理 你可以很快学会 Go 的错误处理模式，重复到令人作呕:\nsomeData, err := SomeFunction() if err != nil { return err; } 因为 Go 声称不支持异常（虽然它已经支持），每个能够以错误结尾的函数都必须把错误作为其最后一个结果。这特别适用于执行某些 I/O 的每个函数，因此这种啰嗦的模式在网络应用程序中非常普遍，这是 Go 的主要领域。\n您很快就会忽视这种模式，并将其识别为「好，错误处理了」，但是仍然很杂乱，有时很难在错误处理中找到实际的代码。\n这里有几个问题，因为一个错误的结果可能有名无实，例如当从无所不在的 io.Reader读取时：\nlen, err := reader.Read(bytes) if err != nil { if err == io.EOF { // 一切正常，文件结尾  } else { return err } } 在“Error has values”中，Rob Pike 提出了一些减少错误处理冗余的策略。我发现它们实际上是危险的创可贴：\ntype errWriter struct { w io.Writer err error } func (ew *errWriter) write(buf []byte) { if ew.err != nil { return // 当已经出错时，什么都不写入  } _, ew.err = ew.w.Write(buf) } func doIt(fd io.Writer) { ew := \u0026amp;errWriter{w: fd} ew.write(p0[a:b]) ew.write(p1[c:d]) ew.write(p2[e:f]) // 等等  if ew.err != nil { return ew.err } } 基本来说，一直检查错误是很痛苦的，所以这里提供了直到结束之前都会忽略错误的方法。任何写入操作一旦出错它还是会执行，即使我们知道不该再执行了。如果这样做资源消耗更高呢？我们刚刚浪费了资源，因为 Go 的错误处理是一种痛苦。\nRust 有类似的问题：没有异常(真的没有，跟 Go 相反)，方法失败返回 Result\u0026lt;T, Error\u0026gt;，并且需要对结果模式匹配。所以，Rust1.0 添加了 try! 宏并且认识到这一模式的普遍性，使它成为 一流的语言特征。因此，在保持正确的错误处理的同时，也有上述代码的简洁性。\n由于 Go 没有泛型和宏，所以很不幸地，更换为 Rust 的方法是不可能的。\nNil 接口值 这是在看到 redditor jmickeyd 展示了 nil 和接口的怪异表现后的更新，这绝对称得上是丑陋的。我稍微扩展了一下：\ntype Explodes interface { Bang() Boom() } // Type Bomb implements Explodes type Bomb struct {} func (*Bomb) Bang() {} func (Bomb) Boom() {} func main() { var bomb *Bomb = nil var explodes Explodes = bomb println(bomb, explodes) // \u0026#39;0x0 (0x10a7060,0x0)\u0026#39;  if explodes != nil { println(\u0026#34;Not nil!\u0026#34;) // \u0026#39;Not nil!\u0026#39; 我们为什么会走到这里！？  explodes.Bang() // 运行正常  explodes.Boom() // panic: value method main.Bomb.Boom called using nil *Bomb pointer  } else { println(\u0026#34;nil!\u0026#34;) // 为什么没有在这里结束？  } } 上面的代码验证了 explodes 不是nil，但是代码在 Boom 中 panics，在 Bang 中没有。这是为什么呢？解释在 println 这一行：bomb 指针是 0x0，它实际上是 nil，但是 explodes 是非nil (0x10a7060,0x0)。\n这两个元素的第一个元素是通过 Explodes 类型来实现 Bomb 接口的方法分派表的指针，第二个元素是实际 Explodes 对象的地址，它是 nil。\n对 Bang 的调用成功是因为它需要传递的是 Bomb 指针：没有必要取消指针来调用方法。Boom 方法作用于一个值，因此调用会导致指针取消引用，这会造成 panic。\n注意，如果我们写了 var explodes Explodes = nil，然后 != nil 本不该通过。\n那么，我们应该如何安全地编写测试呢？我们必须检查接口值，如果是非 nil，检查接口对象指向的值…使用反射!\nif explodes != nil \u0026amp;\u0026amp; !reflect.ValueOf(explodes).IsNil() { println(\u0026#34;Not nil!\u0026#34;) // we no more end up here  explodes.Bang() explodes.Boom() } else { println(\u0026#34;nil!\u0026#34;) // \u0026#39;nil\u0026#39; -- all good! } 这是漏洞还是特性？Go语言之旅 有一个 专门的页面 来解释这种行为，并清楚地表示 「注意，一个具有nil值的接口值本身就是非空值」。\n尽管如此，这仍然是丑陋的，并且会导致非常细微的错误。在我看来，这是语言设计中的一个很大的缺陷，只是为了使它的实现更加容易。\nStruct 字段标记：字符串中的运行时DSL。 如果您在 Go 中使用了 JSON，您肯定遇到过类似的情况：\ntype User struct { Id string `json:\u0026#34;id\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` Name string `json:\u0026#34;name,omitempty\u0026#34;` } 这些是 结构标记(struct tags)，语言规范说这是一个字符串「通过反射接口可见，并参与结构的类型标识，但是却被忽略了」。所以，基本上，把你想要的东西放到这个字符串中，并在运行时使用反射来解析它。如果语法不对，运行时就会出现 panic。\n这个字符串实际上是字段元数据，在许多语言中已经存在了几十年，称为「注释」或「属性」。通过语言支持，它们的语法在编译时被正式定义和检查，同时仍然是可扩展的。\n为什么要决定使用一个原始字符串，任何库都可以决定使用它想要的任何 DSL ，在运行时解析？\n当您使用多个库时，情况会变得很糟糕：这里有一个从协议缓冲区的 Go文档 中取出的示例:\ntype Test struct { Label *string `protobuf:\u0026#34;bytes,1,req,name=label\u0026#34; json:\u0026#34;label,omitempty\u0026#34;` Type *int32 `protobuf:\u0026#34;varint,2,opt,name=type,def=77\u0026#34; json:\u0026#34;type,omitempty\u0026#34;` Reps []int64 `protobuf:\u0026#34;varint,3,rep,name=reps\u0026#34; json:\u0026#34;reps,omitempty\u0026#34;` Optionalgroup *Test_OptionalGroup `protobuf:\u0026#34;group,4,opt,name=OptionalGroup\u0026#34; json:\u0026#34;optionalgroup,omitempty\u0026#34;` } 附注：为什么这些标签在使用 JSON 时如此常见？因为在 Go 公共字段中，必须使用大写字母，或者至少以大写字母开头，而在 JSON 中命名字段的常见约定是小写的 camelcase 或 snake_case。因此需要进行冗长的标记。\n标准的 JSON 编码器 / 解码器不允许提供自动转换的命名策略，就像 Jackson在Java中所做的。这可能解释了为什么 Docker APIs 中的所有字段都是大写的:这避免了它的开发人员为他们的大型 API 编写这些笨拙的标签。\n没有泛型…至少没给你。 很难想象一种没有泛型的现代静态类型化语言，但这就是你在 Go 中看到的：它没有泛型\u0026hellip;或者更精确地说，几乎没有泛型，我们会看到它比没有泛型更糟糕。\n内置的 slice、map、array和 channel 都是泛型。声明一个 map[string]MyStruct 清楚地显示了具有两个参数的泛型类型的使用。这很好，因为它允许类型安全编程捕获各种错误。\n然而，没有用户可定义的泛型数据结构。这意味着您不能定义可重用的抽象，它可以以类型安全的方式使用任何类型。您必须使用非类型 interface{}，并将值转换为适当的类型。任何错误只会在运行时被抓住，会导致 panic。对于 Java 开发人员来说，这就像回到 回退 Java 5 个版本到 2004 年。\n在「少即是多」中，Rob Pike 意外地将泛型和继承放在同一个「类型编程」包中，并说他喜欢组合而不是继承。不喜欢继承很好（实际上我写了很多没有继承的Scala），但是泛型回答了另一个问题：可重用性，同时保护类型安全。\n正如下面我们将看到的，在用泛型做内部构建和用户无法定义泛型之间的区别会对开发人员「舒适」和编译时类型安全产生更多的影响：它会影响整个 Go 生态系统。\nGo 在 slice 和 map 之外几乎没有什么数据结构。 Go 生态系统没有很多数据结构，它们可以从内置的 slices 和 maps 中提供额外或不同的功能。Go 最新版本添加了提供其中几个容器包。它们都有相同的警告：它们处理 interface{} 值，这意味着您将失去所有类型的安全性。\n让我们来看一个 snc.Map 的例子，它是一个具有较低线程争用的并发映射，而不是使用互斥锁来保护常规映射：\ntype MetricValue struct { Value float64 Time time.Time } func main() { metric := MetricValue{ Value: 1.0, Time: time.Now(), } // Store a value  m0 := map[string]MetricValue{} m0[\u0026#34;foo\u0026#34;] = metric m1 := sync.Map{} m1.Store(\u0026#34;foo\u0026#34;, metric) // not type-checked  // Load a value and print its square  foo0 := m0[\u0026#34;foo\u0026#34;].Value // rely on zero-value hack if not present  fmt.Printf(\u0026#34;Foo square = %f\\n\u0026#34;, math.Pow(foo0, 2)) foo1 := 0.0 if x, ok := m1.Load(\u0026#34;foo\u0026#34;); ok { // have to make sure it\u0026#39;s present (not bad, actually)  foo1 = x.(MetricValue).Value // cast interface{} value  } fmt.Printf(\u0026#34;Foo square = %f\\n\u0026#34;, math.Pow(foo1, 2)) // Sum all elements  sum0 := 0.0 for _, v := range m0 { // built-in range iteration on map  sum0 += v.Value } fmt.Printf(\u0026#34;Sum = %f\\n\u0026#34;, sum0) sum1 := 0.0 m1.Range(func(key, value interface{}) bool { // no \u0026#39;range\u0026#39; for you! Provide a function  sum1 += value.(MetricValue).Value // with untyped interface{} parameters  return true // continue iteration  }) fmt.Printf(\u0026#34;Sum = %f\\n\u0026#34;, sum1) } 这就是为什么在 Go 生态系统中没有很多数据结构的一个很好的例子：与内置的切片和映射相比，它们是一种痛苦。原因很简单，数据结构分为两类：\n 上层，内置的 slice，map，array 和 channel：类型安全和泛型，方便使用 range， Go 代码编写的其他地方：不能提供类型安全，因为需要强制转换而难以使用。  因此，库定义的数据结构真的需要为我们的开发人员提供切实的利益，才愿意为松散类型的安全性和额外的代码冗长付出代价。\n当我们想要编写可重用的算法时，内置结构和 Go 代码之间的二元性在细节方面是痛苦的。这是标准库的 排序扩展包 中的一个例子：\nimport \u0026#34;sort\u0026#34; type Person struct { Name string Age int } // ByAge implements sort.Interface for []Person based on the Age field. type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u0026lt; a[j].Age } func SortPeople(people []Person) { sort.Sort(ByAge(people)) } 等等\u0026hellip; 这是认真的吗？我们必须定义一个新的类型 ByAge，它必须实现 3 种方法来实现通用的（严格讲是「可重用」）排序算法和类型切片。\n对我们开发人员来说唯一重要的是，用较少的函数比较两个对象，并且是域依赖的。其他的东西都是噪音和重复，简单的事实是，Go 没有泛型。我们需要对每一种我们想排序的类型重复它，每个比较器也是。\n更新：Michael Stapelberg 指出我忘记了 sort.Slice。看起来好多了，尽管它在 hood (eek!) 下使用反射，并要求比较器函数在切片上做一个闭包去排序，这仍然很难看。\n每个解释 Go 不需要泛型的文章，把这个当做「Go 的方式」，它允许使用可重用的算法，同时避免向下转换到 interface{}\u0026hellip;\n好了。为了缓解疼痛，如果 Go 有可以生成这个无意义的样板的宏就好了，对吗？\ngo generate，还说得过去，但是\u0026hellip; Go 1.4 介绍了 go generate 命令，从源代码的注释中触发代码的生成。嗯，这里的「注释」实际上指的是 //go:generate 的注释，需要符合严格的规则：「注释必须从行开始处开始，在 // 和 go:generate 之间没有空格」。如果写错了，加了一个空格，没有工具会警告你出错了。\n这实际上涵盖了两种应用场景：\n 从其他来源生成 Go 代码：ProtoBuf / Thrift / Swagger 模式，语言语法，等等。 生成的 Go 代码补充了现有的代码，例如作为示例的 stringer ，它为一系列类型常量生成 String() 方法。  第一个用例是可以的，附加价值是你不需要摆弄 makefiles，而生成的说明可以接近生成的代码的用法。\n对于第二个用例，许多语言，比如 Scala 和 Rust，有宏（在 设计文档 中提到的）在编译过程中都可以访问源代码的 AST。Stringer 实际上 导入了Go编译器的解析器 来遍历 AST。Java 没有宏，但注释处理器扮演同样的角色。\n许多语言也不支持宏，所以在这里没有什么根本的错误，除了这个脆弱的由逗号驱动的语法，它看起来像一个快速的技巧，以某种方式完成工作，而不是作为清晰的语言设计被慎重考虑。\n哦，你知道 Go 编译器实际上有 很多注释/程序 和 条件编译 使用这个脆弱的注释语法吗？\n结论 就像你猜到的，我对 Go 爱恨交加。Go 有点像这样的朋友，你喜欢和他一起出去玩，因为他很有趣和他喝啤酒聊天很棒，但是当你想进行更深入的交流时，你会觉得无聊和痛苦，然后你不想和他一起去度假。\n我喜欢 Go 在写高效的 APIs 或网络方面时的简单，goroutines 使这些 很容易解释。当我必须实现业务逻辑时，我讨厌它有限的表现力和所有的等着打击你的语言怪癖和陷阱。\n直到最近，在 Go 占据的领域中并没有出现真正的替代选择，它高效地开发本地可执行文件，而不会导致 C 或 C++ 的痛苦。Rust 在飞速进步，我用得越多，越能发现它的有趣之处和优秀设计。我有一种感觉，Rust 是那些需要时间相处的朋友，你最终会想要和他们建立长期的关系。\n回归技术层面，你会发现一些文章说 Rust 和 Go 不是一个领域的，Rust 是一种系统语言，因为它没有内存回收机制 等等。我认为这越来越不真实了。在 伟大的web框架 和优秀的 ORMs 中 Rust 正在爬得更高。它也给你一种温暖的感觉，“如果它编译，错误将来自我写的逻辑，而不是我忘记注意的语言怪癖”。\n我们还在容器/服务网格区域看到一些有趣的行动， Buoyant（Linkerd的开发商）正在开发它们的新 Kubernetes 服务网格 Conduit 作为一个组合，来自控制层面（我猜可能是因为可用的 Kubernetes库）的 Go 和数据层面拥有良好效率和鲁棒性的 Rust ，以及 Sozu代理。\nSwift 也是这个家庭的一份子，或者是 C 和 C++ 的最新替代品。它的生态系统仍然过于以苹果为中心，即使它现在可以在 Linux 上使用，并且已经有了新的 服务器端 APIs 和 Netty 框架。\n这里当然没有万能药和通用之法。但是知道你所用工具的问题至关重要。我希望这篇博文教会了你关于 Go 你以前没有意识到的问题，这样你就可以避开陷阱!\n几天后：Hacker News 第三名！ 更新，发布3天后：这篇文章反响惊人。它已经成为了 Hacker News 的头版(我看到的最好排名是#3)和/r/programming(我看到的最好排名是#5)，并且在 Twitter 上得到了一些关注。\n这些评论通常都是正面的(甚至是在/r/golang/)，或者至少承认这篇文章是公平的，并且力求公正。/r/rust的人们当然喜欢我对 Rust 的兴趣。我从未听说过的人甚至给我发邮件说：“我只是想让你知道，我认为你写的文章是最好的。感谢您为此付出的所有努力”。\n这是写作时最困难的部分：尽量做到客观公正。这当然不是完全可能的，因为每个人都有自己的偏好，为什么我关注意外的惊喜和语言工程学：语言对你有多大帮助，而不是妨碍你，或者至少是我的方式。\n我还在标准库或 golang.org 上搜索了代码样本，并引用了Go团队的人员，以我对权威材料的分析为基础，避免了“meh，你引用了一个错误的人”的反应。\n写这篇文章用了我两个星期的晚上时间，但是这真的很有趣。当你做严肃而诚实的工作时，你会得到这样的结果：来自技术网络的许多好的共鸣(如果你忽略掉少数捣乱的和一直脾气暴躁的人)。极大调用了我写更多的深度内容的积极性！\n","id":13,"section":"posts","summary":"文章在 Golang 中文网的地址 点击这里，英语原文地址 点击这里。 这是「Go 是一门设计糟糕的编程语言」系列追加的一篇文章。Go 确实有一些不错的特性，因此这","tags":["Go"],"title":"Go 语言的优劣","uri":"https://donng.github.io/2018/05/go-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%8A%A3/","year":"2018"}],"tags":[{"title":"Github","uri":"https://donng.github.io/tags/github/"},{"title":"Go","uri":"https://donng.github.io/tags/go/"},{"title":"JWT","uri":"https://donng.github.io/tags/jwt/"},{"title":"Laravel","uri":"https://donng.github.io/tags/laravel/"},{"title":"Nginx","uri":"https://donng.github.io/tags/nginx/"},{"title":"PHP","uri":"https://donng.github.io/tags/php/"},{"title":"Vue","uri":"https://donng.github.io/tags/vue/"}]}